<b>Репозиторий для лабораторных работ по дисциплинам "Теория и техника передачи информации" и "Основы защиты информации".</b>

В результате прохождения указанных выше дисциплин, удалось изучить и реализовать при помощи языка программирования Java следующие алгоритмы:
 * [Шифр виженера](https://ru.wikipedia.org/wiki/%D0%A8%D0%B8%D1%84%D1%80_%D0%92%D0%B8%D0%B6%D0%B5%D0%BD%D0%B5%D1%80%D0%B0 "Шифр Виженера")
 * [Алгоритм шифрования RSA](https://ru.wikipedia.org/wiki/RSA "Алгоритм шифрования RSA")
 * [Алгоритм Лемпеля — Зива — Велча (LZW)](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%9B%D0%B5%D0%BC%D0%BF%D0%B5%D0%BB%D1%8F_%E2%80%94_%D0%97%D0%B8%D0%B2%D0%B0_%E2%80%94_%D0%92%D0%B5%D0%BB%D1%87%D0%B0 "Алгоритм Лемпеля — Зива — Велча")
 * [Алгоритм шифрования Эль-Гамаля](https://ru.wikipedia.org/wiki/%D0%A1%D1%85%D0%B5%D0%BC%D0%B0_%D0%AD%D0%BB%D1%8C-%D0%93%D0%B0%D0%BC%D0%B0%D0%BB%D1%8F "Алгоритм шифрования Эль-Гамаля")
 * [Алгоритм Хэмминга](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B4_%D0%A5%D1%8D%D0%BC%D0%BC%D0%B8%D0%BD%D0%B3%D0%B0 "Алгоритм Хэмминга")


</br>Принципы работы разработанной программы:
1. [<b>Алгоритм шифрования RSA</b>](https://ru.wikipedia.org/wiki/RSA "Алгоритм шифрования RSA")</br></br>
 Для начала работы с алгоритмом, необходимо вызвать конструктор класса RSA. В него передать два ключа и сообщение с соответствующими символами. Далее нужно лишь вызвать метод run() у созданного объекта.</br>
 В результате на экране появится следующий текст:
 
     ![image](https://github.com/baldehshnik/information-transmission/assets/88383461/7754cfde-84cf-4ad5-82c6-cb14639128b8)

     На данном изображении виден результат программы: введенное сообщение в виде массива символов, зашифрованное сообщение и его расшифровка. Алгоритм отработал успешно!</br></br>
     <b>Примечание:</b> данный алгорит работает только с русским алфавитом (прописные буквы) и пробелами!


2. [<b>Алгоритм Лемпеля — Зива — Велча (LZW)</b>](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%9B%D0%B5%D0%BC%D0%BF%D0%B5%D0%BB%D1%8F_%E2%80%94_%D0%97%D0%B8%D0%B2%D0%B0_%E2%80%94_%D0%92%D0%B5%D0%BB%D1%87%D0%B0 "Алгоритм Лемпеля — Зива — Велча")</br></br>
   Для начала работы необходимо создать объект класса LZW.
   Далее, чтобы сжать текст, необходимо вызвать у этого объекта метод compress(). После этого произойдет сжатие текста, и результат будет выведен в консоль, например:

     ![image](https://github.com/baldehshnik/information-transmission/assets/88383461/f80de990-0e3e-4d61-ab73-93ca23f60721)

     Чтобы разжать текст, необходимо вызвать метод decompress(), который вернет сжатый текст в нормальный вид:

     ![image](https://github.com/baldehshnik/information-transmission/assets/88383461/d9543e98-8bf8-40a5-817b-d262a4a9c1fa)

     <b>Примечание:</b> реализованный алгоритм работает с файлом info.txt, в котором записан текст для сжатия!


3. [<b>Шифр виженера</b>](https://ru.wikipedia.org/wiki/%D0%A8%D0%B8%D1%84%D1%80_%D0%92%D0%B8%D0%B6%D0%B5%D0%BD%D0%B5%D1%80%D0%B0 "Шифр Виженера")</br></br>
   Данная реализация алгоритма работает только с русским алфавитом (заглавными буквами) и нижним подчеркиванием.
   Для начала работы необходимо вызвать конструктор класса Vigenere, в который необходимо передать длину ключа и зашифрованное сообщение. Далее вызываем метод run().
   В результате, программа найдет возможные ключи и выведет их на экран. Помимо ключей, будет показано меню дальнейшего взаимодействия:

     ![image](https://github.com/baldehshnik/information-transmission/assets/88383461/12dd184d-9be2-4d98-bbd7-ee4eb7e7291a)

     Для примера, выберем третий пункт и выведем все расшифрованные текста и найдем правильный. В нашем случае это будет:

     ![image](https://github.com/baldehshnik/information-transmission/assets/88383461/56ceaf5e-56ac-4d37-985e-498cc727952e)

     <b>Примечание:</b> расшифрованный текст будет написан маленькими русскими буквами <b>без</b> знаков препинания!


 4. [<b>Алгоритм шифрования Эль-Гамаля</b>](https://ru.wikipedia.org/wiki/%D0%A1%D1%85%D0%B5%D0%BC%D0%B0_%D0%AD%D0%BB%D1%8C-%D0%93%D0%B0%D0%BC%D0%B0%D0%BB%D1%8F "Алгоритм шифрования Эль-Гамаля")</br></br>
    Для начала работы необходимо создать объект класса Elgamal и вызвать метод run() с передачей в него секретного ключа.
    Далее необходимо вызвать метод encrypt(), в который неообходимо передать шифруемый символ, преобразованный к типу BigInteger.
    Например, зашифруем английскую букву "a" с секретным ключем равным 7. В результате получим следующий текст в консоле:

      ![image](https://github.com/baldehshnik/information-transmission/assets/88383461/2263ff7b-c766-4979-b1b9-738e916b7d4a)

      После вычислений мы получили сообщение об успешном шифровании.
      Для расшифроки необходимо вызвать метод decrypt(). Результат расшифровки мы сможем увидеть в консоле:

      ![image](https://github.com/baldehshnik/information-transmission/assets/88383461/9d5dd22f-2dfd-4eac-b7e9-27e22b41d66d)

      <b>Примечание:</b> реализованный алгоритм работает с любыми доступными символами!


 5. [<b>Алгоритм Хэмминга</b>](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B4_%D0%A5%D1%8D%D0%BC%D0%BC%D0%B8%D0%BD%D0%B3%D0%B0 "Алгоритм Хэмминга")</br></br>
    Для начала работы необходимо вызвать конструктор класса Hamming с данными для обработки и вызвать метод run().
    В консоле мы получим значение введенной строки в виде бит, а также строки в виде бит с учетом контрольных бит.

      ![image](https://github.com/baldehshnik/information-transmission/assets/88383461/db1f1778-a6e1-463f-a235-f7807403fcbb)

      Далее необходимо ввести номер бита, который необходимо будет намеренно сделать ошибочным.
      В результате мы получим наборы бит с учетом ошибки, с исправленной ошибкой и, наконец, восстановленное сообщение:

      ![image](https://github.com/baldehshnik/information-transmission/assets/88383461/badf66be-e410-4d69-8e13-f8f6723d9738)

      <b>Примечание:</b> алгоритм работает с любыми доступными символами. Нумерация бит осуществляется справа налево!


<b>Все алгоритмы реализованы в качестве задания по лабораторной работе! Они могут быть реализованы некорректно и не могут претендовать на право считаться реальной реализацией алгоритма.</b>

   
